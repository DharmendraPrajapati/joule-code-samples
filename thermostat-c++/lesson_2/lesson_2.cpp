//Truly learn to code with Intel on Grosse Tete - Lesson 2

/*
* In the last lesson, you saw a first-step program in c++,
* and in this lesson, you'll learn how to access
* a digital pin on the Grosse Tete.
* 
* Compile with "g++ -lmraa lesson_2.cpp -o lesson_2"
*/

#include <csignal>  //Library from the C/++ standard libraries to allow for clean exits.
#include <cstdlib>  //
#include <unistd.h> //
#include <iostream> //The most commonly-included file. This allows you to use cin and cout to print to the console and collect user input.

#include <mraa.hpp> //Intel's MRAA Library. This library allows the programmer to address the GPIO pins on the development board.

using namespace std; //Commonly considered bad practice, this command prevents some simple mistakes that can be difficult to track down for a beginner. Generally, though, you wouldn't do this.

//This is a global variable which will hold our GPIO object. (General Purpose In/Out)
mraa::Gpio *gpio;

//This function is called a "signal handler." It allows a signal like "SIGINT" to exit the program cleanly.
//In this case, the SIGINT will be generated by the OS when you press Ctrl+C on your keyboard.
void signal_handler(int sig) {
	delete gpio;
	cout << "Exiting." << endl;
	exit(0);
}

//The main entry point for your program. This is the function that the OS (OSTRO) calls when it "runs" your code.
int main(int argc, char **argv) {

	signal(SIGINT, signal_handler); //This sets the event handler to the SIGINT signal. This is the signal generated by Ctrl+c.

	cout << "Hello from Intel on Grosse Tete!" << endl	//Remember, c++ isn't whitespace-sensitive, so you can use "carriage returns" (split lines) in the middle of function calls.
	<< "Press Ctrl+c to exit..." << endl;				//This is very useful when the function call will be long and otherwise unwieldy.

	gpio = new mraa::Gpio(100);	//Instantiate the GPIO object so that we can access the pin. (Pin 100)

	if (gpio) { //If the instantiation was successful...
		gpio->dir(mraa::DIR_OUT); //Set the pin as an output.
		while (true) { //Begin an infinite loop. This will exit on pressing Ctrl+c, due to the event handler.
			gpio->write(1); //gpio->write(n) writes the value "n" to the gpio object. If the value is 1, the output turns off, if it's 0 it turns on. This may seem counterintuitive, but it's called active-low.
			sleep(1);		//sleep(n) is exactly what it says on the tin. It makes the program (or thread) sleep for n seconds.
			gpio->write(0);
			sleep(1);
		}
	}

	delete gpio; //Dispose of the object, now that we no longer need it. This is only needed because the object was allocated on the heap instead of the stack. (I.e. created with a pointer.)
	return 1; //As always, don't forget to return something. In this case, if the code reached this point, there was a problem, so we'll return 1 here.
}
